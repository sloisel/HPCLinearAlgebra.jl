# Generate precompile directives using SnoopCompile
#
# Run this script under MPI to generate src/precompile.jl:
#   mpiexec -n 1 julia --project=. scripts/generate_precompile.jl
#
# Only run with a single MPI rank to avoid file conflicts.

using SnoopCompile
using SnoopCompile.SnoopCompileCore
using SparseArrays
using LinearAlgebra
using MPI

# Initialize MPI first
MPI.Init()

# Load the package outside of @snoop_inference
using LinearAlgebraMPI

# Now snoop on the actual workload
tinf = @snoop_inference begin
    # Small test data for precompilation
    n = 8

    # Sparse matrix (tridiagonal) - Float64
    I_sp = Int[]; J_sp = Int[]; V_sp = Float64[]
    for i in 1:n
        push!(I_sp, i); push!(J_sp, i); push!(V_sp, 4.0)
        if i > 1
            push!(I_sp, i); push!(J_sp, i-1); push!(V_sp, -1.0)
            push!(I_sp, i-1); push!(J_sp, i); push!(V_sp, -1.0)
        end
    end
    A_sparse_f64 = sparse(I_sp, J_sp, V_sp, n, n)

    # Sparse matrix - ComplexF64
    A_sparse_c64 = sparse(I_sp, J_sp, ComplexF64.(V_sp), n, n)

    # Dense matrix - Float64
    A_dense_f64 = Float64[i == j ? 4.0 : (abs(i-j) == 1 ? -1.0 : 0.0) for i in 1:n, j in 1:n]

    # Dense matrix - ComplexF64
    A_dense_c64 = ComplexF64.(A_dense_f64)

    # Vectors
    v_f64 = ones(Float64, n)
    v_c64 = ones(ComplexF64, n)

    # Identity for SPD construction
    I_sparse = sparse(1.0 * LinearAlgebra.I, n, n)

    # === VectorMPI operations (Float64) ===
    v = VectorMPI(v_f64)
    w = VectorMPI(2.0 .* v_f64)
    _ = v + w
    _ = v - w
    _ = 2.0 * v
    _ = v * 2.0
    _ = norm(v)
    _ = dot(v, w)
    _ = conj(v)
    _ = length(v)
    _ = size(v)

    # VectorMPI (ComplexF64)
    vc = VectorMPI(v_c64)
    _ = conj(vc)
    _ = norm(vc)

    # === SparseMatrixMPI operations (Float64) ===
    A = SparseMatrixMPI{Float64}(A_sparse_f64)
    B = SparseMatrixMPI{Float64}(A_sparse_f64)
    _ = A + B
    _ = A - B
    _ = 2.0 * A
    _ = A * v
    _ = A * B
    _ = transpose(A)
    At = SparseMatrixMPI(transpose(A))
    _ = size(A)
    _ = nnz(A)
    _ = norm(A)

    # SparseMatrixMPI (ComplexF64)
    Ac = SparseMatrixMPI{ComplexF64}(A_sparse_c64)
    _ = Ac * vc

    # === MatrixMPI operations (Float64) ===
    D = MatrixMPI(A_dense_f64)
    _ = 2.0 * D
    _ = D * v
    _ = transpose(D)
    Dt = copy(transpose(D))  # Materialize dense transpose
    _ = size(D)
    _ = norm(D)

    # MatrixMPI (ComplexF64)
    Dc = MatrixMPI(A_dense_c64)
    _ = Dc * vc

    # === Mixed operations ===
    _ = A * D  # Sparse * Dense

    # === Indexing ===
    _ = v[1]
    _ = A[1, 1]
    _ = D[1, 1]

    # === Factorization (MUMPS) ===
    # Make symmetric positive definite: A + A^T + 10I
    At_mat = SparseMatrixMPI(transpose(A))
    I_dist = SparseMatrixMPI{Float64}(I_sparse)
    A_spd = A + At_mat + I_dist * 10.0
    F = LinearAlgebra.ldlt(A_spd)
    x = F \ v
    finalize!(F)

    # LU factorization
    F_lu = LinearAlgebra.lu(A)
    x = F_lu \ v
    finalize!(F_lu)

    # === Block operations ===
    _ = cat(v, w; dims=1)
    _ = blockdiag(A, B)

    # === Conversions ===
    _ = Vector(v)
    _ = Matrix(D)
    _ = SparseMatrixCSC(A)

    # Clear caches
    clear_plan_cache!()
end

# Generate precompile directives
# parcel returns (total_time, Vector{Pair{Module, (time, MethodInstances)}})
_, pc = SnoopCompile.parcel(tinf)

# Filter for LinearAlgebraMPI only
pc_filtered = filter(p -> p.first == LinearAlgebraMPI, pc)

# Extract method instances for our module
if !isempty(pc_filtered)
    _, method_instances = pc_filtered[1].second

    # Write the precompile file
    outfile = joinpath(@__DIR__, "..", "src", "precompile.jl")
    open(outfile, "w") do io
        println(io, "# Precompile directives generated by SnoopCompile")
        println(io, "# Regenerate with: mpiexec -n 1 julia --project=. scripts/generate_precompile.jl")
        println(io, "#")
        println(io, "# $(length(method_instances)) method instances")
        println(io)
        println(io, "function _precompile_()")
        println(io, "    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing")
        SnoopCompile.write(io, method_instances)
        println(io, "end")
        println(io)
        println(io, "_precompile_()")
    end

    println("Generated precompile directives: $outfile")
    println("Found $(length(method_instances)) method instances")
else
    println("No method instances found for LinearAlgebraMPI")
end
